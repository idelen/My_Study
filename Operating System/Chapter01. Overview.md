<h1> Chapter01. Overview </h1>

<h2>What Operating Systems Do</h2>

---

* 운영체제(Operating Systems) 

  : 컴퓨터 하드웨어를 관리하고, <strong>하드웨어와 소프트웨어, 사용자를 매개하는 프로그램</strong>

* 커널(Kernel)

  : 운영체제의 핵심이며 실체.

- 운영체제 = 커널 + 커널모듈(Kernel Module)
- 커널은 운영체제의 핵심이기에 일반적으로 <i>"운영체제 == 커널"</i>



- 컴퓨터 시스템의 요소
  1. 하드웨어(CPU, 메모리, 입출력장치 등)
  2. 운영체제
  3. 어플리케이션 프로그램(웹 브라우저, 워드프로세서 등)
  4. 유저

- 운영체제의 역할은 사용자 관점(User View)과 시스템 관점(System View)으로 나눠볼 수 있다.

```markdown
1. User View 
-> 일반적으로 사용자가 컴퓨터 앞에 앉아 키보드와 마우스로 조작하는 경우
	- 운영체제는 사용자가 컴퓨터 자원 사용(Resource Utilization)을 신경쓰지 않게 돕는다.
	(사용자가 컴퓨터를 쉽게 이용할 수 있도록 한다.)
-> 사용자가 메인프레임(MainFrame)에 연결된 터미널을 사용하거나 미니컴퓨터(MiniComputer)를 사용하는 경우
	- 컴퓨터의 자원을 여러 사용자가 나눠쓸 때, 사용자들이 자원을 공평하게 사용할 수 있도록 돕는다.

2. System View
-> 시스템에게 운영체제는 **자원 할당자(Resource allocator)**다.
-> CPU 시간, 메모리 공간, 파일 저장소 공간, 입출력 장치 등 다양한 문제를 해결해야 한다.
-> 운영체제는 이러한 컴퓨터 자원들을 관리하는 **제어 프로그램(Control Program)**으로 동작한다.
	
```





<h2>Computer-System Organization </h2>

---

![현대 컴퓨터 시스템. CPU와 장치 컨트롤러들이 버스를 통해 메모리에 연결.](https://t1.daumcdn.net/cfile/tistory/99DF283A5ABE280904)

- 현대의 일반적인 컴퓨터 시스템은 여러개의 CPU와 장치 컨트롤러(Device Controllers)로 구성되어 있다.
- 이들은 공통버스(Common bus)로 이어져 메모리를 공유한다.



<h3>Computer Startup</h3>

```markdown
1. 컴퓨터를 켜면 부트스트랩 프로그램(Bootstrap Program)이라는 초기화 프로그램이 실행된다.
	- 이 프로그램은 컴퓨터의 ROM이나 EEPROM(Electrically Erasable Programmable Read-Only Memory)에 저장
	- 주로 **펌웨어(Firmware)**라고 불린다.
2. 부트스트랩 프로그램은 시스템을 초기화하고, 부트로더(boot loader)를 실행한다.
	- 멀티부팅 컴퓨터의 경우 부트로더가 여러 운영체제를 가리키며, 어떤 운영체제를 실행할지 선택해야 함.
3. 부트로더가 최종적으로 운영체제를 실행
4. 커널이 로드, 실행되면 시스템과 사용자에게 서비스를 제공해야 한다.
	- 이 때, 일부 서비스는 커널 외부에서 제공되는데, 이들은 부팅할 때 메모리에 로드되는 시스템 프로세스(System 	Processes)나 시스템 데몬(System Daemons)이다.
	- UNIX의 경우 첫 시스템 프로세스는 `init`이며, 이 프로세스는 또 다른 데몬들을 실행시킨다.
5. 데몬은 프로세스로 백그라운드에서 돌면서 시스템 로그를 남기는 등의 여러 작업을 수행한다.
6. 이러한 과정이 끝나면 시스템이 완전히 부팅되고, 이벤트가 발생하기를 기다리게 된다.
```



<h3> Computer-System Operation</h3>

- 입출력 장치와 CPU는 동시에 실행될 수 있다.

- **인터럽트(Interrupt)**

  -> 컴퓨터에서 신호를 보내 이벤트 발생을 알리는 것을 의미

  -> 컴퓨터에세 여러 작업을 동시에 처리할 때, 당장 처리해야 하는 일이 생겨서 기존의 작업을 잠시 중단해야 하는겨우 인터럽트 신호를 보냄.

- 인터럽트의 종류   <- ?????????????????????????????????

  1. 트랩(Trap) : 소프트웨어에 의해 발생하는 인터럽트
  2. 하드웨어의 경우 시스템 버스(System Bus)를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생
  3. 시스템 콜(System Call) : 소프트웨어의 특별한 명령으로 발생하는 인터럽트



<h3> Common Functions of Interrupts</h3>

```markdown
1. CPU가 인터럽트 신호를 받으면, 하던 일을 멈추고 메모리의 어떤 고정된 위치(Fixed Location)를 찾는다.
-> 이 위치는 **인터럽트 벡터(Interrupt Vector)** 에 저장되어 있다.
	- 인터럽트 벡터 : 인터럽트를 처리할 수 있는 서비스 루틴(Service Routine)들의 주소를 가지고 있는 공간
	ex) 파일 읽기/쓰기와 같은 중요한 동작들이 하드코딩되어 있음
2. 인터럽트를 처리하고나면 CPU가 다시 원래 작업으로 돌아온다.
```



<h3> Interrupt Handling</h3>

- 현대 운영체제들은 대부분 **인터럽트 주도적(Interrupt Driven)** 이다.

- 인터럽트가 발생하기 전까지 CPU는 대기상태에 머문다.

- 반면, **폴링(Polling)**의 경우 주기적으로 이벤트를 감시해 처리 루틴을 실행

  -> 이렇게 하면 컴퓨팅 자원을 낭비하기 때문에 인터럽트 주도적으로 설계하는 것!!



<h2>Storage Structure</h2>

---

- 커널은 실행기(Executor)을 통해 프로그램을 실행
- 실행기는 기억장치(Storage)에서 exe파일(Windows의 경우) 을 가져오고, 커널이 메모리에 할당해 실행
- 메인 메모리 == RAM (Random-Access Memory)
- RAM은 용량이 작고 휘발성
- 보조기억장치 (자기테이프, 광학디스트, 자기디시크, SSD 등)
- 보조기억장치는 용량이 크고 저렴한 반면, 캐시나 레지스터는 용량이 작고 비싸다.



<H2>I/O Structure</h2>

---

- 기억장치도 여러 입출력장치(I/O devices) 중 하나이다.
- 입출력 컨트롤러는 각각 다른 장치를 담당
- 운영체제는 각 장치 컨트롤러를 제어하기 위한 장치 드라이버(Device Driver)을 가지고 있다.

```markdown
1. 입출력 명령을 수행하기 위해 장치 드라이버는 장치 컨트롤러의 레지스터를 로드한다.
2. 장치 컨트롤러는 레지스터에서 "키보드로부터 문자 읽어오기"와 같은 동작을 읽고, 장치에서 로컬 버퍼(Local buffer)로 데이터를 전송한다.
3. 전송이 끝나면 장치 컨트롤러는 장치드라이버에게 인터럽를 보내 동작이 끝남을 알린다.
4. 장치 드라이버는 통제권을 운영체제에거 돌려준다. (이때, 입력받은 데이터나 상태 정보를 넘겨주기도 함)
```

- 사용자 프로그램은 커널과 사용자 프로그램을 매개하는 인터페이스인 **시스템 콜(System Call)** 을 통해 입출력을 요청할 수 있다.



<h2> Direct Memory Access Structure</h2>

---

- 과거에는 장치 데이터를 처리하기 위해 CPU를 거쳐 메모리에 로드 (PIO; Programmed I/O 방식)
- 현재는 CPU 자원이 너무 많이 소모되기 때문에 DMA를 사용
- **DMA는 장치와 메모리를 직접 연결하는 방식으로, 버스가 지원하는 기능**
- 메모리의 일정 부분이 DMA에 사용될 영역으로 지정되며, DMA를 제어하는 컨트롤러는 ``DMA 컨트롤러`` 라 부름.
- 장치의 데이터는 장치 컨트롤러에 의해 직접 메모리에 전달, CPU에서 데이터 이동이 완료되었다는 인터럽트는 **한 번** 만 일어난다. -> CPU가 하는 일이 줄어들어 성능 향상



<h2> Computer-System Architecture </h2>

---

![현대 컴퓨터 시스템의 동작 원리. CPU, 메모리, 장치.](https://t1.daumcdn.net/cfile/tistory/991F994F5ABE663601)

<h3> Single-Processor Systems</h3>

- 과거 대부분의 컴퓨터 시스템

- 장치에 따라 특별한 목적을 가진 프로세스를 가짐

  ex) 디스크 프로세서는 디스크 연산만 수행, 키보드 프로세스는 키보드 연산만 수행

<h3> Multiprocessor Systems</h3>

- 처음에는 서버 컴퓨터에 적용됐고, 지금은 모바일 기기도 멀티 프로세서 시스템으로 만듬

- 멀티 프로세스 시스템의 장점

  1. 처리량(Throughput)의 증가

  2. 규모의 경제

     : 멀티프로세서 시스템은 주변장치(Peripherals)을 공유할 수 있기 때문에 구축에 돈이 덜 든다.

  3. 신뢰성의 증가

     : 하나의 프로세서가 작동을 멈춰도 전체 시스템이 느려질 뿐 멈추지 않는다.

     - 우아한 성능저하(Graceful Degradation) : 성능이 나빠지지만 작동은 가능하도록 하는 것
     - 장애 허용 시스템(Fault Tolerant) : 성능을 저하함으로써 작업을 계속 유지하는 시스템

- 멀티 프로세스 시스템의 종류

  1. 비대칭 멀티프로세싱(Asymmetric Multiprocessing)

     -보스 프로세서가 시스템을 제어하고, 다른 프로세서들은 보스의 지시를 받는다.

     -부하 분산(Loadbalancing)을 효율적으로 할 수 있지만, 보스가 멈추면 일꾼도 멈춘다.

  2. 대칭 멀티프로세싱(Symmetric Multiprocessing)

     -모든 프로세서들이 하나의 메모리를 공유하고, 동일한 작업을 병렬적으로 수행

     -프로세서가 작동을 멈춰야 한다면 자신이 수행하던 작업을 다른 프로세서들에게 나눠주고 자신만 재부팅

- 대부분의 컴퓨터 시스템은 **대칭 멀티프로세싱** 을 사용

![대칭 멀티프로세싱 아키텍처.](https://t1.daumcdn.net/cfile/tistory/99BE2C425ABE741E0A)



<h3> A Dual-Core Desing</h3>

![같은 칩에 두 개의 코어가 들어간 듀얼코어 설계.](https://t1.daumcdn.net/cfile/tistory/996247375ABE741502)

- CPU가 늘어나면 프로세스간 통신을 하는데 많은 비용이 들기 떄문에 효율이 계속 좋아지지는 않음
- 최근 CPU 설계 트랜드는 하나의 칩(Chip)에 코어(Cores)를 늘리는 것
- 코어 : 동일한 성능의 CPU 여러 개를 1개의 칩 속에 집접한 것
- 칩 내부의 통신(On-chip communication)이 칩 사이의 통신(Between-chip communication)보다 더 빠르기 때문

<h3> Clustered Systems</h3>

- 여러 독립적인 시스템이 모여 하나의 시스템을 이루며, 이런 시스템을 약결합(Loosely coupled)라고 부름
- 각 노드들은 싱글 프로세서 시스템일수도 있고, 멀티코어 시스템일 수도 있다.



<h2> Operating System Structure</h2>

---

- 운영체제의 가장 중요한 부분 중 하나는 멀티프로그램(Multiprogram) 능력이다.

- **멀티프로그래밍(Multiprogramming)**

  : 여러 프로그램을 메모리에 로드해 두고 한 프로세스가 대기 상태가 되면 다른 프로세스의 작업을 수행하는 시스템

  -> CPU의 사용 효율을 높일 수 있다. (디스크에 있는 것은 프로그램, 메인메모리에 있는 것은 프로세스)

- **시분할(Time Sharing) 시스템** == 멀티태스킹(Multitasking)

  : 프로세스마다 작업 시간을 정해두고 번갈아가면서 작업하는 방식

  -> 사용자 입장에서는 마치 동시에 작동하는 것처럼 보임 / 반응시간(Response time)을 줄이는 것이 중요

- 여러 작업들을 동시에 메모리에 올리는 방식이기에 운영체네는 메모리에 자리가 없는 경우를 고려해 어떤 작업을 먼저 처리할지 정해야한다.  --> **작업 스케줄링(Job Scheduling), CPU 스케줄링(CPU Scheduling)**

- 메모리를 너무 많이 사용하게 될 경우, 반응 시간을 줄이기 위해 가상 메모리(Virtual Memory)를 사용

- 가상 메모리

  : 보조기억장치의 일부를 메인 메모리처럼 사용하는 기술로, 실제 물리 메모리(Physical Memory)보다 더 큰 프로그램을 구동할 수 있도록 해준다.



<h2> Dual-Mode and Multimode Operation</h2>

---

![사용자 모드에서 커널 모드로 변경되는 과정. 시스템 콜을 이용.](https://t1.daumcdn.net/cfile/tistory/99D9DB355AC0E4342A)

- 운영체제는 사용자 프로그램이 함부로 시스템에 접근하지 못하도록 모드(Modes)를 나눈다.

  -> 하드웨어의 모드비트가 `0` 이면 커널모드(Kernel Mode) / `1` 이면 유저모드(User Mode)

- 하드웨어는 커널 모드일때만 **특권 명령(Privileged Instructions)** 을 실행

- 유저모드에서 특권 명령을 실행하려 하면 하드웨는 동작을 막고 운영체제에 트랩을 전송

- 유저모드에서 커널 모드의 기능을 호출하려면 **시스템 콜(System Call)** 인터페이스를 통해야 함



<h2> Timer </h2>

---

- 운영체제는 사용자의 프로그램이 제어권을 운영체제에게 넘겨주지 않는 상황을 방지하기 위해 타이머를 사용
- "타이머" 는 운영체제에게 제어권을 보장하기 위해 특정 주기에 <i>인터럽트</i> 를 발생
- 운영체제는 카운터를 설정하고, 타이머의 시간은 매 틱(Ticks) 마다 감소 -> 카운터가 0에 도달하면 인터럽트 발생



<h2> Process Management</h2>

---

- 프로세스는 프로그램이 어디까지 실행되었느지 북마크하는 `프로그램 카운터(Program Counter)`을 가진다.

  : 싱글스레드 프로세스는 하나, 멀티스레드 프로세스는 여러개의 프로그램 카운터를 가진다.

- 프로세스 관리를 위한 운영체제의 역할

```markdown
1. CPU에게 프로세스와 스레드를 스케줄링
2. 프로세스를 생성하거나 제거, 일시정지나 재실행을 수행
3. 프로세스의 동기화(Synchronization)와 통신도 제공
```



<h2> Storage Management</h2>

---

- 운영체제는 저장장치의 물리적 속성을 추상화해 파일(File)이라는 논리적 저장 단위로 정의하며, 파일을 물리적 매체(Physical Media)에 담거나 저장장치의 파일에 접근하기도 한다.

<h3> File-System Management</h3>

- 파일 관리는 운영체제가 하는 일 중 가장 눈에 잘 보이는 요소
- 파일을 생성, 제거 및 읽기, 쓰기를 수행

<h3> Mass-Storage Management</h3>

- NTFS, FAT 가 파일 저장 형식이며, 이를 파일 시스템(File System)이라고 부른다.

<h3> Caching</h3>

- 캐시 메모리를 사용해 컴퓨터의 속도를 높이는 기술

- 데이터를 디스크에서 직접 가져오는 것은 너무 느리기 때문에 캐시에 자주 사용될 것 같은 데이터를 미리 담아두고, CPU나 디스크가 캐시의 데이터를 참조할 수 있도록 한다.

  -> 파일의 중복성이 증가하지만, 속도 역시 증가한다.

- **지역성(Locality)**

  1. 시간지역성(Temporal locality)

     : 한 번 접근한 데이터에 다시 접근할 확률이 높다.

  2. 공간지역성(Spatial locality)

     : 특정 데이터와 가까운 메모리 주소에 있는 다른 데이터들에도 접근할 가능성이 높다.

  ```c++
  for(int i = 0 ; i< 10; i++) {
      arr[i] += 1;
  }
  ```

  -> 배열 변수 `arr` 의 0번 요소부터 순서대로 9번 요소까지 접근

  -> 캐시는 한 메모리 주소에 접근했을 때 그 주변의 메모리 주소도 함께 가져온다.

<h3> I/O System</h3>

- 운영체제는 모든 입출력장치를 파일로 취급
- 오직 장치드라이버(Device driver) 만이 장치의 자세한 정보를 알고 있다.



<h2> Protection and Security</h2>

---

- 운영체제는 내외부로부터 컴퓨터를 위험하게 만드는 요소를 막기 위해 다양한 활동을 한다.

  ex) 유저모드와 커널모드를 나누는 것 등

- **권한 확대(Privilege Escalation)**

  : 사용자의 권한을 구분해 어떤 행동이나 기준에 따라 사용자의 권한을 상승시키는 시스템

  1) 수직 권한 확대 : 임의의 코드를 실행시켜 더 높은 권한을 얻는 행위

  2) 수평 권한 확대 : 안드로이드 루팅, iOS 탈옥 등

<h2> Kernel Data Structures</h2>

---

- 커널 구현에는 기본적인 리스트(List), 스택(Stack), 큐(Queue), 링크드리스트(Linked list) 등의 자료구조를 사용
- 트리(Tree)는 O(log n) 의 시간복잡도를 가지는 효율적인 알고리즘이기에 자주 사용



<h2> Computing Environments</h2>

---

- 모바일 컴퓨팅(Moblie Computing)

  : 컴퓨터의 접근성을 높였고, 다양한 센서를 통해 사용자와의 인터페이스를 확장

- 분산형 컴퓨팅(Distributed Computing), 클라이언트-서버 컴퓨팅(Client-Server Computing), P2P컴퓨팅(Peer-to-Peer Computing) 등 다양한 컴퓨팅 환경이 존재

- AWS(Amazon Web Service)는 대표적인 클라우드 컴퓨팅(Cloud Computing)

- 현대 컴퓨팅 환경의 가장 큰 특징은 **휴대성, 가상화, 멀티코어**



<h2> Open-Source Operating Systems</h2>

---

- 세상에는 많은 오픈소스 운영체제들이 있다. 당장 깃허브에서도 리눅스의 코드를 찾아볼 수 있다. 오픈소스 운영체제 개발에는 누구나 참여할 수 있고, 이를 이용해 새로운 운영체제를 만들 수도 있다.





