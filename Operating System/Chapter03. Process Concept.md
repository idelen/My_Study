<h1> Chapter03. Process Concept</h1>

<h2> Process State</h2>

---

- new : 프로세스가 처음 생성될 때
- ready : 프로세서에게 할당되기를 기다릴 때
- running : 프로세서에 할당되어 실행될 때
- terminated : 실행 중 종료될 때
- waiting : 실행 중 작업이 완료되어 입출력을 기다릴 때



<h2>Process Control Block(PCB)</h2>

---

- PCB에는 프로세스 상태와 프로그램 카운터, 메모리 한계, 레지스터 정보 등이 담겨있다.

<h3>CPU Switch</h3>

- 프로세스가 실행되다가 인터럽트가 발생해 운영체제가 개입하여 **프로세서에 할당된 프로세스를 바꾸는 것**
- 시스템 콜을 사용해야 하는 경우 운영체제가 개입
- CPU 스위칭을 할 때는 작업중이던 프로세스의 PCB를 백업



<h2> Threads</h2>

---

- 프로세스를 쪼개 하나의 프로세스 안에서 동시에 여러 작업을 처리할 수 있다.



<h2>Process Scheduling </h2>

---

- 어떤 프로세스를 프로세서에 할당할 것인가를 결정하는 일

- **레디 큐(Ready queue)**

  : ready 상태의 프로세서가 쌓여 있는 곳

- Long-term 스케줄러 : 레디 큐에 프로세스를 옮기는 스케줄러 / CPU 밖에서 작업

- Short-term 스케줄러 : 프로세서를 프로세서에 할당하는 스케줄러



<h2> Context Switch</h2>

---

- 프로세스가 스위치할 때, 작업중이던 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 로드하는 행위
- 프로세스 입장에서는 PCB 정보가 바뀌는 것
- 오버헤드가 발생하는 작업이기 떄문에 너무 자주 일어나면 성능을 저하한다.



<h2>Process Creration</h2>

---

- 프로세스는 트리 구조이다. 즉,  부모 프로세스가 자식 프로세스를 만든다.

- PCB에 저장된 `pid` 값으로 프로세스를 식별

- `fork()` 함수를 호출하면 부모 프로세스는 자신과 똑같은 자식 프로세스를 생성한다. 

  -> 부모 프로세스에겐 자식 프로세스의 `pid` 를, 자식프로세스에겐 `0` 을 반환한다.

- `exec()` 함수를 통해 자식 프로세스를 내용을 바꾼다.



<h2> Process Termination</h2>

---

- `exit()`를 호출하면 프로세스를 종료한다.
- 자식 프로세스가 종료되었는데, 부모 프로세스가 자식 프로세스가 반환한 정보를 회수하지 않으면 자식 프로세스는 종료되었음에도 정보가 메모리에 남아있는 좀비 프로세스가 된다.



<h2> Interprocess Communication (IPC)</h2>

---

<h3> Message passing</h3>

- 송신 프로세스가 정보를 받는 수신 프로세스에게 **커널을 통해 정보를 전달**한다.
- 수신 프로세스도 **커널에 접근해 정보를 수신**한다.
- 컨텍스트 스위치가 발생하기에 속도가 느리다.
- 단, 커널이 기본적인 기능을 제공하므로 공유 메모리 방식에 비해선 구현이 쉽다.

<h3> Shared Memory</h3>

- 특정 메모리 공간을 두 프로세스가 함께 사용하며 정보를 주고 받는다.
- 커널을 거치지 않기에 속도가 빠르지만 메모리의 동시 접근을 방지하기 위한 기능 구현이 필요

<h3>Producer-Consumer Problem</h3>

​	: 두 프로세스가 동시에 동작할 때 일어나는 이슈

- 생산자(Producer) : 협력하는 프로세스 중 정보를 생산하는 프로세스
- 소비자(Consumer) : 정보를 소비하는 프로세스
- 보통 정보가 생산되는 속도가 소비하는 속도보다 빠르기 때문에 동기화 문제가 발생
- 이를 해결하기 위해 생상된 데이터를 담아두는 **버퍼(Buffer)** 를 사용
- 크기에 한계가 있는 버퍼를 유한 버퍼(Bounded Buffer) / 버퍼의 시작과 끝을 이어붙여 크기가 무한한 무한 버퍼(Unbounded Buffer) 라고 한다.

<h3> Synchroniztion</h3>

​	: 메세지 패싱의 동기화 문제를 해결하기 위해 blocking 방식과 non-blocking 방식이 사용된다.

```markdown
- Blocking send : 수신자가 메시지를 받을 때까지 송신자는 block된다.
- Blocking receive : 메시지를 수신할 때까지 수신자는 block된다.
- Non-blocking send : 송신자가 메시지를 보내고 작업을 계속한다.
- Non-blocking receive : 수신자가 유효한 메시지나 Null 메시지를 받는다.
```



<h2> Sockets</h2>

---

- 서버와 클라이언트가 통신하는 방식
- **IP주소와 포트정보가 있으면 클라이언트는 네트워크를 통해 서버 프로세스에 접근** 할 수 있다.
- RPC(Remote Procedure Calls) : 프로세스와 프로세스가 네트워크로 이어여 있을 때 발생하는 호출
- 서버와 클라이언트가 통신할 때는 IP주소와 포트를 래핑해서 Stub으로 만들어 전송한다.



<h2>Pipes</h2>

---

- 부모 프로세스와 자식 프로세스가 통신할 때 사용하는 방식
- 파이프는 **단반향 통신** 만 가능
- 양방향으로 정보를 주고 받으려면 두 개의 파이프가 필요 (파이프는 파일)
- 파이프에 이름을 붙인 named pipe를 사용하면 꼭 부모-자식 관계가 아니더라도 파이프를 이용해 통신할 수 있다.

